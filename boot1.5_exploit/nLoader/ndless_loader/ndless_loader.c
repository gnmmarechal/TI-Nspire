/*
 * nLoader
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2, as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA.
 */

#include "../types.h"
#include "patchos.h"
#include "../patcherloc.h"
#include "../casos.h"

#define put_word(A,B) *(volatile uint32_t *)(A) = (B)

#define CR4 (*(volatile uint32_t *)0xa4012eb0 >= 0x04000000) // can't be function here

static const uint32_t selfd_patch_addr[] = { // patch discrepancy for OS 3.6+
    SELFD_CX360_5XX,
    SELFD_CXC360_546_550,
    SELFD_CX440_532,
    SELFD_CXC440_532,
    SELFD_CX450_1180,
    SELFD_CXC450_1180,
};
static const uint32_t asic1_patch_addr[] = {
    ASIC1_CX360_5XX,
    ASIC1_CXC360_546_550,
    ASIC1_CX440_532,
    ASIC1_CXC440_53X,
    ASIC1_CX450_1180,
    ASIC1_CXC450_1180,
};
static const uint32_t asic2_patch_addr[] = {
    ASIC2_CX440_532,
    ASIC2_CXC440_532,
    ASIC2_CX450_1180,
    ASIC2_CXC450_1180,
};
static const uint32_t ndless_load_addr[] = {
    BOOT2UPD_CX360_5XX,
    BOOT2UPD_CXC360_546_550,
    BOOT2UPD_CX440_532,
    BOOT2UPD_CXC440_53X,
    BOOT2UPD_CX450_1180,
    BOOT2UPD_CXC450_1180,
};
static const uint32_t ndless_loader_model_specific[][5] = {
    /* fopen,				stat,		 			malloc,					fread,				fclose */
    {FOPEN_CX360_5XX, 		STAT_CX360_5XX,			MALLOC_CX360_5XX,		FREAD_CX360_5XX,		FCLOSE_CX360_5XX},
    {FOPEN_CXC360_546_550, 	STAT_CXC360_546_550,	MALLOC_CXC360_546_550,	FREAD_CXC360_546_550,	FCLOSE_CXC360_546_550},
    {FOPEN_CX440_532,		STAT_CX440_532,			MALLOC_CX440_532,		FREAD_CX440_532,		FCLOSE_CX440_532},
    {FOPEN_CXC440_532,		STAT_CXC440_532,		MALLOC_CXC440_532,		FREAD_CXC440_532,		FCLOSE_CXC440_532},
    {FOPEN_CX450_1180,		STAT_CX450_1180,		MALLOC_CX450_1180,		FREAD_CX450_1180,		FCLOSE_CX450_1180},
    {FOPEN_CXC450_1180,		STAT_CXC450_1180,		MALLOC_CXC450_1180,		FREAD_CXC450_1180,		FCLOSE_CXC450_1180},
};

void __attribute__((naked)) ndless_loader(void) {
    uint32_t id=*((volatile uint32_t *)0x10000020);
    unsigned char asicflags = ((*(volatile unsigned int*) 0x900A002C)>>26)&0b11111; /* can't be a function here */
    int32_t os_misc=-1;  int bad = 0; int cas = -1;
    switch (id) {
            // REVERSE ORDER AS ABOVE!
        case CXC450_1180:
            if(cas == -1) cas = 1;
            os_misc++;
        case CX450_1180:
            if(cas == -1) cas = 0;
            os_misc++;
        case CXC440_532:
            if(cas == -1) cas = 1;
            os_misc++;
        case CX440_532:
            if(cas == -1) cas = 0;
            os_misc++;
            if(cas == 1 && asicflags != 1) {
                *(uint32_t*)(asic2_patch_addr[os_misc]+0x118)=0x04000001; // CX CAS ASIC2
                *(uint16_t*)(asic2_patch_addr[os_misc])=0x2110;
                *(uint32_t*)(asic2_patch_addr[os_misc]+8)=0;
            } else if(cas == 0 && asicflags != 0){
                *(uint32_t*)(asic2_patch_addr[os_misc]+0x118)=0; // CX ASIC2
                *(uint16_t*)(asic2_patch_addr[os_misc])=0x2110;
                *(uint32_t*)(asic2_patch_addr[os_misc]+8)=0;
            }
        case CXC360_546_550:
            if(cas == -1) cas = 1;
            os_misc++;
        case CX360_5XX:
            if(cas == -1) cas = 0;
            os_misc++;
            if(cas == 1 && asicflags != 1) {
                *(uint32_t*)(asic1_patch_addr[os_misc]+0x17)=0xE3A04341; // CX CAS ASIC2
                *(uint32_t*)(asic1_patch_addr[os_misc]+0x48B)=0x00010105; // CX CAS ASIC1
                *(uint8_t*)asic1_patch_addr[os_misc]=0x54;
                *(uint32_t*)(asic1_patch_addr[os_misc]+0x1B)=0;
            } else if(cas == 0 && asicflags != 0){
                *(uint32_t*)(asic1_patch_addr[os_misc]+0x17)=0xE3A04000; // CX ASIC2
                *(uint32_t*)(asic1_patch_addr[os_misc]+0x48B)=0; // CX ASIC1
                *(uint8_t*)asic1_patch_addr[os_misc]=0x54;
                *(uint32_t*)(asic1_patch_addr[os_misc]+0x1B)=0;
            }
            *(uint32_t*)selfd_patch_addr[os_misc]=0xE12FFF1E;
            break;
        default:
            bad = 1; // fixme: 3.3 has no ndless
    }
    int iscr4 = CR4;
    if(id == CXC360_546_550) {
        if(iscr4) bad = 1;
        else *(volatile unsigned int*) NBOOT_CXC360_546_550 = 0;
    } else 	if(id == CX360_5XX) {
        if(iscr4) bad = 1;
        else *(volatile unsigned int*) NBOOT_CX360_5XX = 0;
    }
    if(bad) {
        // red screen, thanks geekpersonman
        volatile unsigned char *scr_base = (*(void**)0xC0000010);
        volatile unsigned char *ptr;
        unsigned scr_size = 320*240*2;
        for (ptr = scr_base; ptr < scr_base + scr_size; ptr += 2) {
            *(volatile unsigned short*)ptr = 0b1111100000000000;
        }
        while(1) { };
    }
    // put back boot2 4.4.0.8 ver
    *(volatile uint32_t*)0xA4012EB4 = 0x04280008;
    static uint32_t ndless_loader[] = { NDLESS_LOADER };
    os_misc=-1;
    switch (id) {
            // REVERSE ORDER AS ABOVE!
        case CXC450_1180:
            os_misc++;
        case CX450_1180:
            os_misc++;
        case CXC440_532:
            os_misc++;
        case CX440_532:
            os_misc++;
        case CXC360_546_550:
            os_misc++;
        case CX360_5XX:
            os_misc++;
            __builtin_memcpy(ndless_loader+OFFSET_MODEL, ndless_loader_model_specific[os_misc], sizeof(ndless_loader_model_specific[0]));
            uint32_t * dest = (uint32_t *)ndless_load_addr[os_misc];
            for (uint32_t i = 0; i < sizeof(ndless_loader)/sizeof(ndless_loader[0]); i++)
                *dest++ = ndless_loader[i];
    }
#ifdef CAS_OS
#ifndef CAS_OS_no_patches
    if(id == CXC440_532 && asicflags != 1) {
        ((void (*)())PATCHER44CAS_LOC)();
    } else if(id == CXC450_1180 && asicflags != 1) {
        ((void (*)())PATCHER45CAS_LOC)();
    }
#endif
#endif
#ifdef NONCAS_OS
    if(id == CX440_532 && asicflags != 0) {
        ((void (*)())PATCHER44NCAS_LOC)();
    } else if(id == CX450_1180 && asicflags != 0) {
        ((void (*)())PATCHER45NCAS_LOC)();
    }
#endif
    // CX-C all languages
    // it is the location of "/supportedLocales"
    if(id == CXC450_1180) {
        put_word(0x10b1783c,0);
    } else if(id == CX450_1180) {
        put_word(0x10ab26b0,0);
    } else if(id == CXC440_532) {
        put_word(0x10b040f4,0);
    } else if(id == CX440_532) {
        put_word(0x10a9ee18,0);
    } else if(id == CXC360_546_550) {
        put_word(0x10a7c450,0);
    } else if(id == CX360_5XX) {
        put_word(0x10a1b46c,0);
    }
    __asm volatile(
                   "LDR    PC, =0x1187d308 \n"
                   ); // after it prints launching image
    __builtin_unreachable();
}
